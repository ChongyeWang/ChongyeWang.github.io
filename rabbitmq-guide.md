## RabbitMQ实战指南(Note)

### 消息中间件的作用

解耦: 在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程 中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独 立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。

冗余(存储): 有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直 到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息已经被处理完成，从而确保你的数据被安全地保 存直到你使用完毕。

扩展性: 因为消息中间件解耦了应用的处理过程，所以提高消息入队和处理的效率是很容 易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。

削峰: 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常 见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关 键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。

可恢复性: 当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的 耦合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后 进行处理。

顺序保证: 在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程 度上的顺序性。

缓冲: 在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓 冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制 和优化数据流经过系统的速度。

异步通信: 在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制， 允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。 


### 特点
RabbitMQ 的具体特点可以概括为以下几点:

可靠性: RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认及发布确认等。

灵活的路由: 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 已经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起，也可以通过插件机制来实现自己的交换器。

扩展性: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。

高可用性: 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。

多种协议: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息 中间件协议。

多语言客户端: RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、 C#、JavaScript 等。

管理界面: RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。

插件机制: RabbitMQ提供了许多插件，以实现从多方面进行扩展，当然也可以编写自 己的插件。


RabbitMQ 中消息都只能存储在队列中，这一点和 Kafka 这种消息中间件相反。Kafka 将消 息存储在 topic(主题)这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移 标识。RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。
多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(Round-Robin，即轮询) 给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理 

生产者将消息发送给交换器时，需要一个 RoutingKey，当 BindingKey 和 RoutingKey 相匹 配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如 fanout 类型的交换器就会无视 BindingKey，而是将消息路由到所有绑定到该交换器的队列中。 

RabbitMQ 常用的交换器类型有 fanout、direct、topic、headers 这四种。


Fanout: 它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。

direct 类型的交换器路由规则也很简单，它会把消息路由到那些 BindingKey 和 RoutingKey 完全匹配的队列中。 

topic 类型的交换器在匹配规则上进行了 扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队 列中，但这里的匹配规则有些不同，它约定:

- RoutingKey 为一个点号“.”分隔的字符串(被点号“.”分隔开的每一段独立的字符 串称为一个单词)，如“com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;

- BindingKey 和 RoutingKey 一样也是点号“.”分隔的字符串;

- BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“#”用 于匹配一个单词，“#”用于匹配多规格单词(可以是零个)。 

headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中 的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时， RabbitMQ 会获取到该消息的 headers(也是一个键值对的形式)，对比其中的键值对是否完全 匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由 到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。 

### 消费模式

RabbitMQ 的消费模式分两种:推(Push)模式和拉(Pull)模式。推模式采用 Basic.Consume 进行消费，而拉模式则是调用 Basic.Get 进行消费。 
Basic.Consume 将信道(Channel)置为接收模式，直到取消队列的订阅为止。在接收 模式期间，RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 Basic.Qos 的限制。如果只想从队列获得单条消息而不是持续订阅，建议还是使用 Basic.Get 进行消费。但 是不能将 Basic.Get 放在一个循环里来代替 Basic.Consume，这样做会严重影响 RabbitMQ 的性能。如果要实现高吞吐量，消费者理应使用 Basic.Consume 方法。 

### 消费端的确认与拒绝 
为了保证消息从队列可靠地达到消费者，RabbitMQ 提供了消息确认机制(message acknowledgement)。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false 时，RabbitMQ 会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上 是先打上删除标记，之后再删除)。当 autoAck 等于 true 时，RabbitMQ 会自动把发送出去的 消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。
采用消息确认机制后，只要设置 autoAck 参数为 false，消费者就有足够的时间处理消息 (任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直
等待持有消息直到消费者显式调用 Basic.Ack 命令为止。
当 autoAck 参数置为 false，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分: 一部分是等待投递给消费者的消息;一部分是已经投递给消费者，但是还没有收到消费者确认 信号的消息。如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者已经 断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可 能还是原来的那个消费者。 
RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的 唯一依据是消费该消息的消费者连接是否已经断开，这么设计的原因是 RabbitMQ 允许消费者 消费一条消息的时间可以很久很久。 

### 死信队列 
DLX，全称为 Dead-Letter-Exchange，可以称之为死信交换器，也有人称之为死信邮箱。当 消息在一个队列中变成死信(dead message)之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。

消息变成死信一般是由于以下几种情况: 
- 消息被拒绝(Basic.Reject/Basic.Nack)，并且设置requeue参数为false; 
- 消息过期;
- 队列达到最大长度。
DLX 也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实 际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动地将这个消息重 新发布到设置的 DLX 上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消 息以进行相应的处理，这个特性与将消息的 TTL 设置为 0 配合使用可以弥补 immediate 参数的功能。 

### 多租户与权限 
每一个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机(virtual host)， 简称为 vhost。每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器，拥有自己独立的队列、 交换器及绑定关系等，并且它拥有自己独立的权限。vhost 就像是虚拟机与物理服务器一样，它 们在各个实例间提供逻辑上的分离，为不同程序安全保密地运行数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。vhost 之间是绝对隔离 的，无法将 vhost1 中的交换器与 vhost2 中的队列进行绑定，这样既保证了安全性，又可以确保 可移植性。如果在使用 RabbitMQ 达到一定规模的时候，建议用户对业务功能、场景进行归类 区分，并为之分配独立的 vhost。
