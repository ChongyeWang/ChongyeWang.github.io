### 消息通信

生产者(producer)创建消息，然后发布(发送)到代理服务器 (RabbitMQ)。什么是消息呢?消息包含两部分内容:有效载荷(payload)和标签(label)。有效载荷就是你想要传输的数据。它可以是任何内容，一个JSON数组或者是你最喜欢的iguana Ziggy 的 MPEG-4。RabbitMQ不会在意这些。标签就更有趣了。它描述了有效载荷，并且RabbitMQ用它来决定谁将获得消息的拷贝。举例来说，不同于TCP协议的是，当你明确指定发送方和接收方时，AMQP只会用标签表述这条消息(一个交换器的名称和可选的主题标记)，然后把消息交由Rabbit。Rabbit会根据标签把消息发送给感兴趣的接收方。这种通信方式是一种“发后即忘”(fire-and-forget)的单向方式。

消费者很容易理解。它们连接到代理服务器上，并订阅到队列 (queue)上。把消息队列想象成一个具名邮箱。每当消息到达特定的 邮箱时，RabbitMQ会将其发送给其中一个订阅的/监听的消费者。当消 费者接收到消息时，它只得到消息的一部分:有效载荷。在消息路由 过程中，消息的标签并没有随有效载荷一同传递。RabbitMQ甚至不会告诉你是谁生产/发送了消息。就好比你拿起信件时，却发现所有的信 封都是空白的。想要知道这条消息是否是从Millie姑妈发来的唯一方式是她在信里签了名。同理，如果需要明确知道是谁生产的AMQP消息 的话，就要看生产者是否把发送方信息放入有效载荷中。

你必须首先连接到Rabbit，才能消费或者发布消息。你在应用程序和Rabbit代理服务器之间创建一条TCP连接。一旦TCP连接打开(你 通过了认证)，应用程序就可以创建一条AMQP信道。信道是建立在 “真实的”TCP连接内的虚拟连接。AMQP命令都是通过信道发送出去 的。每条信道都会被指派一个唯一ID(AMQP库会帮你记住ID的)。不论是发布消息、订阅队列或是接收消息，这些动作都是通过信道完成 的。你也许会问为什么我们需要信道呢?为什么不直接通过TCP连接发送AMQP命令呢? 主要原因在于对操作系统来说建立和销毁TCP会话是非 常昂贵的开销。假设应用程序从队列消费消息，并根据服务需求合理 调度线程。假设你只进行TCP连接，那么每个线程都需要自行连接到 Rabbit。也就是说高峰期有每秒成百上千条连接。这不仅造成TCP连接 的巨大浪费，而且操作系统每秒也就只能建立这点数量的连接。因此，你可能很快就碰到性能瓶颈了。如果我们为所有线程只使用一条 TCP连接以满足性能方面的要求，但又能确保每个线程的私密性，就像拥有独立连接一样的话，那不就非常完美吗?这就是要引入信道概念的原因。


消费者接收到的每一条消息都必须进行确认。消费者必须通过AMQP的basic.ack命令显式地向RabbitMQ 发送一个确认，或者在订阅到队列的时候就将auto_ack参数设置为true。当设置了auto_ack时，一旦消费者接收消息，RabbitMQ会自动视其确认了消息。需要记住的是，消费者对消息的确认和告诉生产者 消息已经被接收了这两件事毫不相关。因此，消费者通过确认命令告诉RabbitMQ它已经正确地接收了消息，同时RabbitMQ才能安全地把消 息从队列中删除。

如果消费者收到一条消息，然后确认之前从Rabbit断开连接(或 者从队列上取消订阅),RabbitMQ会认为这条消息没有分发，然后重新 分发给下一个订阅的消费者。如果你的应用程序崩溃了，这样做可以 确保消息会被发送给另一个消费者进行处理。另一方面，如果应用程 序有bug而忘记确认消息的话，Rabbit将不会给该消费者发送更多消息了。这是因为在上一条消息被确认之前，Rabbit会认为这个消费者并 没有准备好接收下一条消息。你可以好好利用这一点。如果处理消息 内容非常耗时，则你的应用程序可以延迟确认该消息，直到消息处理 完成。这样可以防止Rabbit持续不断的消息涌向你的应用而导致过载。 

每一个RabbitMQ服务器都能创建虚拟 消息服务器，我们称之为虚拟主机(vhost)。每一个vhost本质上是 一个mini版的RabbitMQ服务器，拥有自己的队列、交换器和绑定。更重要的是，它拥有自己的权限机制。


如果消息想要从 Rabbit崩溃中恢复，那么消息必须:
* 把它的投递模式选项设置为2(持久)
*  发送到持久化的交换器
* 到达持久化的队列

RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件。当发布一条持久性消息到持久 交换器上时，Rabbit会在消息提交到日志文件后才发送响应。 

和事务相仿，你需要告诉Rabbit将信道设置成confirm模式，而且你只能通过重新创建信道来关闭该设置。一旦信道进入confirm模式，所有在信道上 发布的消息都会被指派一个唯一的ID号(从1开始)。一旦消息被投递给所有匹配的队列后，信道会发送一个发送方确认模式给生产者应用程序(包含消息的唯一ID)。这使得生产者知晓消息已经安全到达目 的队列了。如果消息和队列是可持久化的，那么确认消息只会在队列将消息写入磁盘后才会发出。发送方确认模式的最大好处是它们是异步的。一旦发布了一条消息，生产者应用程序就可以在等待确认的同 时继续发送下一条。当确认消息最终收到的时候，生产者应用的回调方法就会被触发来处理该确认消息。如果Rabbit发生了内部错误从而 导致了消息的丢失，Rabbit会发送一条nack(not acknowledged，未确认)消息。就像发送方确认消息那样，只不过这次说明的是消息已经丢失了。同时，由于没有消息回滚的概念(同事务相比)，因此发 送方确认模式更加轻量级，同时对Rabbit代理服务器的性能影响几乎可以忽略不计。


### 集群

RabbitMQ会始终记录以下四种类型的内部元数据:
* 队列元数据——队列名称和它们的属性(是否可持久化，是否 自动删除?) 
* 交换器元数据——交换器名称、类型和属性(可持久化等) 
* 绑定元数据—— 一张简单的表格展示了如何将消息路由到队 列 
* vhost元数据——为vhost内的队列、交换器和绑定提供命名空 间和安全属性 

在单一节点内，RabbitMQ会将所有这些信息存储在内存中，同时 将那些标记为可持久化的队列和交换器(以及它们的绑定)存储到硬 盘上。存储到硬盘上可以确保队列和交换器在重启RabbitMQ节点后重 新创建。当你引入集群时，RabbitMQ需要追踪新的元数据类型:集群 节点位置，以及节点与已记录的其他类型元数据的关系。集群也提供了选择:将元数据存储到磁盘上(独立节点的默认设置)，或者仅存储在RAM中。

在将两个节点组成集群的那一刻，事情发生了巨大的变化:不是 每一个节点都有所有队列的完全拷贝。在单一节点设置中，所有关于 队列的信息(元数据、状态和内容)都完全存储在该节点上。但是如果在集群中创建队列的话，集群只会在单个节点而不是 在所有节点上创建完整的队列信息(元数据、状态、内容)。结果是只有队列的所有者节点知道有关队列的所有信息 。所有其他非所有者节点只知道队列的元数据和指向该队列存在的那个节点的指针。 因此当集群节点崩溃时，该节点的队列和关联的绑定就都消失了。附加在那些队列上的消费者丢失了其订阅信息，并且任何匹配该队列绑 定信息的新消息也都丢失了。

为什么默认情况下RabbitMQ不将队列内 容和状态复制到所有的节点上呢?
有两个原因:
(1)存储空间——如果每个集群节点都拥有所有队列的完整拷贝，那么添加新的节点不会给你带来更多存储空间。举个例子，如果一个节点可以存储1GB的消息，那么添加两个节点只会给你带来两个一 模一样的1GB消息的拷贝。
(2)性能——消息的发布需要将消息复制到每一个集群节点。对于持久化消息来说，每一条消息都会触发磁盘活动。每次新增节点， 网络和磁盘负载都会增加，最终只能保持集群性能的平稳(甚至更 糟)。

相对于默认情况下队列的完整信息存在于集群中 的单一节点来说，集群中的每个节点拥有每个交换器的所有信息。就 可用性来讲，这非常棒，因为这意味着你不用担心在节点故障时重新 声明交换器。只需让故障节点上的生产者重新连接到集群上，它们立 即就能开始往交换器上发布消息了。

如果消息在路由到从拷贝前，镜像队列的主拷贝发生故障，并且该从拷贝变成了主拷贝的话，那么发送方确认消息永远不会到达，于是你就知道消息可能已经丢失了。不过，这只是关于发 布方是如何处理镜像队列主节点故障的。

如果镜像队列失去了一个从节点的话，则附加在镜像队列的任何消费者都不会注意到这一点。这是因为从技术上来讲，它们是附加在队列主拷贝上的。但是如果托管主拷贝的节点发生故障的话，那么所有该队列的消费者需要重新附加并监听新的队列主拷贝。对于通过故障节点进行连接的消费者来说，这倒没什么困难的。因为它们丢失了到节点的TCP连接，在它们重新附加到集群中一个新的节点时，会自动 选取新的队列主拷贝。但对于那些通过节点附加到镜像队列且节点正常运行的消费者来说，RabbitMQ会发送给这些消费者一个消费者取消 (consumer cancellation)通知，告知它们已不再附加在队列主拷贝 了。如果AMQP客户端库能够支持消费者取消通知的含义，那么它会抛 出一个异常，同时应用程序就会知道已经不再附加到队列上了，需要重新附加。另一方面，如果你的客户端库不支持消费者取消的话，那事情就难办了。客户端无法通知应用程序其指向队列主拷贝的消费循环已不复存在。因此你的应用程序呆坐在那里，以为队列里没有消息可供消费。不幸的是，针对这种情况并没有好的解决方法(譬如， Rabbit关闭消费者的信道以强制抛出异常)。所以如果客户端库不能 支持消费者取消通知的话，你应该避免使用镜像队列。不然的话，你 的队列会被未消费的消息塞满，然后监控系统就会在半夜用电话叫醒你。

当镜像队列的主节点失败时， Rabbit不得不对那些已经投递到消费者，但尚未得到确认的消息做个决定。虽然消息确实投递给了消费者，但是Rabbit却不能区分故障转 移中丢失的确认消息和那些尚未得到确认的消息。所以为了安全起见，已经消费但尚未被确认的消息会重新入队到它们所原来在的队列 位置(或者在队列的末尾，在版本2.7.0之前)。
